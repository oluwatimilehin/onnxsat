import base64

from collections import namedtuple
from typing import List

import logging
import traceback

from egglog import Expr
from onnx import NodeProto, AttributeProto, TensorProto

from .lexer import *
from eggie.operators import *


logger = logging.getLogger(__name__)


Attribute = namedtuple("Attribute", ["name", "egg_token_kind", "onnx_attr_type"])


class EggParser:
    def __init__(self, expression: Expr):
        self.lexer = Lexer(str(expression))
        self.vars = {}
        self._nodes = []

    def parse(self) -> List[NodeProto]:
        token = self.lexer.next_token()

        # parse the variable declarations generated by egglog
        try:
            while token.kind != EgglogTokenKind.OP:
                if token.kind != EgglogTokenKind.VARIABLE_NAME:
                    raise ValueError(f"Expected variable name, received {token}")

                variable_name = token.text
                self._validate(self.lexer.next_token(), EgglogTokenKind.EQUALS)

                self.vars[variable_name] = self._parse_token_(self.lexer.next_token())

                token = self.lexer.next_token()

            self._parse_op()

            # pop right parenthesis
            token = self.lexer.next_token()
            return self._nodes
        except Exception as e:
            traceback.print_exc()
            raise e

    def _validate(self, token: EgglogToken, expected_kind: EgglogTokenKind):
        if expected_kind == EgglogTokenKind.TENSOR_ID and (
            token.kind == EgglogTokenKind.TENSOR_ID or token.kind == EgglogTokenKind.OP
        ):
            return

        if token.kind != expected_kind:
            raise ValueError(f"Expected {expected_kind}, received {token}")

    def _validate_and_parse(self, token: EgglogToken, expected_kind: EgglogTokenKind):
        if token.kind == EgglogTokenKind.VARIABLE_NAME:
            return self.vars[token.text]

        return self._parse_token_(token)

    def _parse_token_(self, token: EgglogToken):
        match token.kind:
            case EgglogTokenKind.INTEGER_LITERAL:
                return int(token.text)
            case EgglogTokenKind.FLOAT_LITERAL:
                return float(token.text)
            case EgglogTokenKind.OP:
                return self._parse_op()
            case EgglogTokenKind.VEC:
                return self._parse_vector()
            case EgglogTokenKind.STRING_LITERAL:
                return token.text
            case EgglogTokenKind.TENSOR_ID:
                return self._parse_tensor_id()
            case EgglogTokenKind.TENSOR_TYPE:
                return self._parse_tensor_type()
            case EgglogTokenKind.AVG_POOL_ATTRS:
                return self._parse_average_pool_attrs()
            case EgglogTokenKind.BATCH_NORM_ATTRS:
                return self._parse_batch_norm_attrs()
            case EgglogTokenKind.CONV_ATTRS:
                return self._parse_conv_attrs()
            case EgglogTokenKind.FUSED_CONV_ATTRS:
                return self._parse_fused_conv_attrs()
            case EgglogTokenKind.FUSED_GEMM_ATTRS:
                return self._parse_fused_gemm_attrs()
            case EgglogTokenKind.GEMM_ATTRS:
                return self._parse_gemm_attrs()
            case EgglogTokenKind.MAX_POOL_ATTRS:
                return self._parse_max_pool_attrs()
            case EgglogTokenKind.QUANTIZE_LINEAR_ATTRS:
                return self._parse_quantize_linear_attrs()
            case EgglogTokenKind.VARIABLE_NAME:
                return self.vars[token.text]
            case _:
                raise ValueError(f"Unsupported token: {token}")

    def _parse_tensor_id(self) -> String:
        token = self.lexer.next_token()

        if token.kind == EgglogTokenKind.LEFT_PARENTHESIS:
            val = self._validate_and_parse(
                self.lexer.next_token(), EgglogTokenKind.STRING_LITERAL
            )
            self._validate(self.lexer.next_token(), EgglogTokenKind.RIGHT_PARENTHESIS)
        else:
            val = self._parse_op()

        return val

    def _parse_tensor_type(self) -> TensorProto:
        # pop left parenthesis
        self.lexer.next_token()

        dims = self._validate_and_parse(self.lexer.next_token(), EgglogTokenKind.VEC)

        data_type = self._validate_and_parse(
            self.lexer.next_token(), EgglogTokenKind.INTEGER_LITERAL
        )

        raw_data = self._validate_and_parse(
            self.lexer.next_token(), EgglogTokenKind.STRING_LITERAL
        )

        # pop right parenthesis
        self.lexer.next_token()

        return TensorProto(
            dims=dims, data_type=data_type, raw_data=base64.b64decode(raw_data)
        )

    def _get_attribute(self, attribute: Attribute, token_value) -> AttributeProto:
        name = attribute.name
        type = attribute.onnx_attr_type

        match type:
            case AttributeProto.INT:
                return AttributeProto(name=name, type=AttributeProto.INT, i=token_value)
            case AttributeProto.INTS:
                return AttributeProto(
                    name=name, type=AttributeProto.INTS, ints=token_value
                )
            case AttributeProto.STRING:
                return AttributeProto(
                    name=name, type=AttributeProto.STRING, s=token_value.encode()
                )
            case AttributeProto.FLOAT:
                return AttributeProto(
                    name=name, type=AttributeProto.FLOAT, f=token_value
                )
            case AttributeProto.FLOATS:
                return AttributeProto(
                    name=name, type=AttributeProto.FLOATS, floats=token_value
                )
            case AttributeProto.TENSOR:
                return AttributeProto(
                    name=name, type=AttributeProto.TENSOR, t=token_value
                )
            case _:
                raise ValueError(
                    f"Received unsupported attribute type: {type} with values: {token_value}"
                )

    def _get_attributes(self, attributes: List[Attribute]) -> List[AttributeProto]:
        results: List[AttributeProto] = []

        for attribute in attributes:
            value = self._validate_and_parse(
                self.lexer.next_token(), attribute.egg_token_kind
            )
            if isinstance(value, list) and all(
                isinstance(attr, AttributeProto) for attr in value
            ):
                results += value
            else:
                results.append(self._get_attribute(attribute, value))

        return results

    def _parse_average_pool_attrs(self) -> List[AttributeProto]:
        # pop left parenthesis
        self.lexer.next_token()

        attributes = [
            Attribute(
                "auto_pad", EgglogTokenKind.STRING_LITERAL, AttributeProto.STRING
            ),
            Attribute("ceil_mode", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT),
            Attribute(
                "count_include_pad", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT
            ),
            Attribute("kernel_shape", EgglogTokenKind.VEC, AttributeProto.INTS),
            Attribute("pads", EgglogTokenKind.VEC, AttributeProto.INTS),
            Attribute("strides", EgglogTokenKind.VEC, AttributeProto.INTS),
        ]

        results = self._get_attributes(attributes)

        # pop right parenthesis
        self.lexer.next_token()
        return results

    def _parse_batch_norm_attrs(self) -> List[AttributeProto]:
        # pop left parenthesis
        self.lexer.next_token()

        attributes = [
            Attribute("epsilon", EgglogTokenKind.FLOAT_LITERAL, AttributeProto.FLOAT),
            Attribute("momentum", EgglogTokenKind.FLOAT_LITERAL, AttributeProto.FLOAT),
        ]

        results = self._get_attributes(attributes)

        # pop right parenthesis
        self.lexer.next_token()
        return results

    def _parse_conv_attrs(self) -> List[AttributeProto]:
        # pop left parenthesis
        self.lexer.next_token()

        attributes = [
            Attribute(
                "auto_pad", EgglogTokenKind.STRING_LITERAL, AttributeProto.STRING
            ),
            Attribute("group", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT),
            Attribute("dilations", EgglogTokenKind.VEC, AttributeProto.INTS),
            Attribute("kernel_shape", EgglogTokenKind.VEC, AttributeProto.INTS),
            Attribute("pads", EgglogTokenKind.VEC, AttributeProto.INTS),
            Attribute("strides", EgglogTokenKind.VEC, AttributeProto.INTS),
        ]

        results = self._get_attributes(attributes)

        # pop right parenthesis
        self.lexer.next_token()
        return results

    def _parse_fused_conv_attrs(self) -> List[AttributeProto]:
        self._validate(self.lexer.next_token(), EgglogTokenKind.LEFT_PARENTHESIS)

        attributes = [
            Attribute(
                "activation", EgglogTokenKind.STRING_LITERAL, AttributeProto.STRING
            ),
            Attribute("activation_params", EgglogTokenKind.VEC, AttributeProto.FLOATS),
            Attribute(
                "auto_pad", EgglogTokenKind.STRING_LITERAL, AttributeProto.STRING
            ),
            Attribute("group", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT),
            Attribute("dilations", EgglogTokenKind.VEC, AttributeProto.INTS),
            Attribute("kernel_shape", EgglogTokenKind.VEC, AttributeProto.INTS),
            Attribute("pads", EgglogTokenKind.VEC, AttributeProto.INTS),
            Attribute("strides", EgglogTokenKind.VEC, AttributeProto.INTS),
        ]

        results = self._get_attributes(attributes)

        self._validate(self.lexer.next_token(), EgglogTokenKind.RIGHT_PARENTHESIS)
        return results

    def _parse_fused_gemm_attrs(self) -> List[AttributeProto]:
        self._validate(self.lexer.next_token(), EgglogTokenKind.LEFT_PARENTHESIS)

        attributes = [
            Attribute(
                "activation", EgglogTokenKind.STRING_LITERAL, AttributeProto.STRING
            ),
            Attribute(
                "activation_alpha", EgglogTokenKind.FLOAT_LITERAL, AttributeProto.FLOAT
            ),
            Attribute(
                "activation_beta", EgglogTokenKind.FLOAT_LITERAL, AttributeProto.FLOAT
            ),
            Attribute(
                "activation_gamma", EgglogTokenKind.FLOAT_LITERAL, AttributeProto.FLOAT
            ),
            Attribute("alpha", EgglogTokenKind.FLOAT_LITERAL, AttributeProto.FLOAT),
            Attribute("beta", EgglogTokenKind.FLOAT_LITERAL, AttributeProto.FLOAT),
            Attribute("transA", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT),
            Attribute("transB", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT),
        ]

        results = self._get_attributes(attributes)

        # pop right parenthesis
        self._validate(self.lexer.next_token(), EgglogTokenKind.RIGHT_PARENTHESIS)
        return results

    def _parse_gemm_attrs(self) -> List[AttributeProto]:
        # pop left parenthesis
        self.lexer.next_token()

        attributes = [
            Attribute("alpha", EgglogTokenKind.FLOAT_LITERAL, AttributeProto.FLOAT),
            Attribute("beta", EgglogTokenKind.FLOAT_LITERAL, AttributeProto.FLOAT),
            Attribute("transA", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT),
            Attribute("transB", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT),
        ]

        results = self._get_attributes(attributes)

        # pop right parenthesis
        self.lexer.next_token()
        return results

    def _parse_max_pool_attrs(self) -> List[AttributeProto]:
        # pop left parenthesis
        self.lexer.next_token()

        attributes = [
            Attribute(
                "auto_pad", EgglogTokenKind.STRING_LITERAL, AttributeProto.STRING
            ),
            Attribute("ceil_mode", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT),
            Attribute(
                "storage_order", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT
            ),
            Attribute("dilations", EgglogTokenKind.VEC, AttributeProto.INTS),
            Attribute("kernel_shape", EgglogTokenKind.VEC, AttributeProto.INTS),
            Attribute("pads", EgglogTokenKind.VEC, AttributeProto.INTS),
            Attribute("strides", EgglogTokenKind.VEC, AttributeProto.INTS),
        ]

        results = self._get_attributes(attributes)

        # pop right parenthesis
        self.lexer.next_token()
        return results

    def _parse_quantize_linear_attrs(self) -> List[AttributeProto]:
        # pop left parenthesis
        self.lexer.next_token()

        attributes = [
            Attribute("axis", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT),
            Attribute(
                "block_size", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT
            ),
            Attribute(
                "output_dtype", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT
            ),
            Attribute("saturate", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT),
        ]

        results = self._get_attributes(attributes)

        # pop right parenthesis
        self.lexer.next_token()
        return results

    def _parse_vector(self):
        results = []

        self._validate(self.lexer.next_token(), EgglogTokenKind.LEFT_SQUARE_BRACKET)

        # pop keyword
        self.lexer.next_token()

        # pop right square bracket
        self._validate(self.lexer.next_token(), EgglogTokenKind.RIGHT_SQUARE_BRACKET)

        token = self.lexer.next_token()  # Can be a left parenthesis or a dot

        # empty vector handling
        if token.kind == EgglogTokenKind.DOT:
            assert self.lexer.next_token().text == "empty"
            # Pop '()'
            self.lexer.next_token()
            self.lexer.next_token()
            return results

        while token.kind != EgglogTokenKind.RIGHT_PARENTHESIS:
            token = self.lexer.next_token()

            if token.kind == EgglogTokenKind.RIGHT_PARENTHESIS:
                break

            result = self._parse_token_(token)
            if result == None:
                continue

            if isinstance(token, list):
                results.extend(result)
            else:
                results.append(result)

        return results

    def _parse_op(self) -> NodeProto:
        self._validate(self.lexer.next_token(), EgglogTokenKind.DOT)
        op = self._validate_and_parse(
            self.lexer.next_token(), EgglogTokenKind.STRING_LITERAL
        )

        val: NodeProto = None

        match op:  # TODO: I shouldn't hardcode these ops
            case "Add":
                val = self._parse_add()
            case "AveragePool":
                val = self._parse_average_pool()
            case "BatchNormalization":
                val = self._parse_batch_norm()
            case "Clip":
                val = self._parse_clip()
            case "Concat":
                val = self._parse_concat()
            case "Conv":
                val = self._parse_conv()
            case "Constant":
                val = self._parse_constant()
            case "DequantizeLinear":
                val = self._parse_dequantize_linear()
            case "Dropout":
                val = self._parse_dropout()
            case "Empty":
                val = self._parse_empty()
            case "Flatten":
                val = self._parse_flatten()
            case "FusedConvActivation":
                val = self._parse_fused_conv_activation()
            case "FusedConvBatchNorm":
                val = self._parse_fused_conv_batch_norm()
            case "FusedGemm":
                val = self._parse_fused_gemm()
            case "Gather":
                val = self._parse_gather()
            case "Gemm":
                val = self._parse_gemm()
            case "GroupConv":
                val = self._parse_group_conv()
            case "GlobalAveragePool":
                val = self._parse_global_average_pool()
            case "MatMul":
                val = self._parse_matmul()
            case "MaxPool":
                val = self._parse_max_pool()
            case "Mul":
                val = self._parse_mul()
            case "Pad":
                val = self._parse_pad()
            case "QuantizeLinear":
                val = self._parse_quantize_linear()
            case "QLinearAdd":
                val = self._parse_q_linear_add()
            case "QLinearConv":
                val = self._parse_q_linear_conv()
            case "QLinearGlobalAveragePool":
                val = self._parse_q_linear_global_average_pool()
            case "QLinearMatMul":
                val = self._parse_q_linear_matmul()
            case "ReduceMean":
                val = self._parse_reduce_mean()
            case "Relu":
                val = self._parse_relu()
            case "Reshape":
                val = self._parse_reshape()
            case "Shape":
                val = self._parse_shape()
            case "Sigmoid":
                val = self._parse_sigmoid()
            case "Softmax":
                val = self._parse_softmax()
            case "Split":
                val = self._parse_split()
            case "Squeeze":
                val = self._parse_squeeze()
            case "Transpose":
                val = self._parse_transpose()
            case "Unsqueeze":
                val = self._parse_unsqueeze()
            case _:
                raise ValueError(f"Unknown operation found: {op}")

        return val

    def _get_operation(self) -> str:
        self._validate(self.lexer.next_token(), EgglogTokenKind.DOT)

        return self._validate_and_parse(
            self.lexer.next_token(), EgglogTokenKind.STRING_LITERAL
        )

    def _get_node(
        self,
        op_type: str,
        input_types: List[EgglogTokenKind],
        output_types: List[EgglogTokenKind],
        attributes: List[Attribute] = [],
        has_domain: bool = False,
    ) -> NodeProto:
        self._validate(self.lexer.next_token(), EgglogTokenKind.LEFT_PARENTHESIS)

        name = self._validate_and_parse(
            self.lexer.next_token(), EgglogTokenKind.TENSOR_ID
        )

        domain = None
        if has_domain:
            domain = self._validate_and_parse(
                self.lexer.next_token(), EgglogTokenKind.TENSOR_ID
            )

        attributes: List[AttributeProto] = self._get_attributes(attributes)

        inputs: List[str] = []
        for egg_type in input_types:
            token = self.lexer.next_token()
            value = self._validate_and_parse(token, egg_type)

            if isinstance(value, NodeProto):
                value = value.output[0]

            if token.kind == EgglogTokenKind.VEC:
                inputs += [
                    val.output[0] if isinstance(val, NodeProto) else val
                    for val in value
                ]
            elif value:
                inputs.append(value)

        outputs: List[str] = []
        for egg_type in output_types:
            token = self.lexer.next_token()
            value = self._validate_and_parse(token, egg_type)
            if isinstance(value, NodeProto):
                value = value.output[0]

            if token.kind == EgglogTokenKind.VEC:
                outputs += [
                    val.output[0] if isinstance(val, NodeProto) else val
                    for val in value
                ]
            else:
                outputs.append(value)

        self._validate(self.lexer.next_token(), EgglogTokenKind.RIGHT_PARENTHESIS)

        node = NodeProto(
            name=name,
            domain=domain,
            attribute=attributes,
            input=inputs,
            output=outputs,
            op_type=op_type,
        )
        self._nodes.append(node)
        return node

    def _parse_add(self) -> NodeProto:
        input_types = [EgglogTokenKind.TENSOR_ID, EgglogTokenKind.TENSOR_ID]
        output_types = [EgglogTokenKind.TENSOR_ID]

        return self._get_node("Add", input_types, output_types)

    def _parse_average_pool(self) -> NodeProto:
        input_types = [EgglogTokenKind.TENSOR_ID]
        output_types = [EgglogTokenKind.TENSOR_ID]

        attributes = [Attribute("attrs", EgglogTokenKind.AVG_POOL_ATTRS, None)]

        return self._get_node("AveragePool", input_types, output_types, attributes)

    def _parse_batch_norm(self) -> NodeProto:
        input_types = [EgglogTokenKind.TENSOR_ID for _ in range(5)]
        output_types = [EgglogTokenKind.TENSOR_ID]

        attributes = [Attribute("attrs", EgglogTokenKind.BATCH_NORM_ATTRS, None)]

        return self._get_node(
            "BatchNormalization", input_types, output_types, attributes
        )

    def _parse_clip(self) -> NodeProto:
        input_types = [
            EgglogTokenKind.TENSOR_ID,
            EgglogTokenKind.TENSOR_ID,
            EgglogTokenKind.TENSOR_ID,
        ]
        output_types = [EgglogTokenKind.TENSOR_ID]

        return self._get_node("Clip", input_types, output_types)

    def _parse_concat(self) -> NodeProto:
        input_types = [EgglogTokenKind.VEC]
        output_types = [EgglogTokenKind.TENSOR_ID]

        attrs = [Attribute("axis", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT)]
        return self._get_node("Concat", input_types, output_types, attrs)

    def _parse_conv(self) -> NodeProto:
        input_types = [
            EgglogTokenKind.TENSOR_ID,
            EgglogTokenKind.TENSOR_ID,
            EgglogTokenKind.TENSOR_ID,
        ]
        output_types = [EgglogTokenKind.TENSOR_ID]

        attrs = [Attribute("attrs", EgglogTokenKind.CONV_ATTRS, None)]

        return self._get_node("Conv", input_types, output_types, attrs)

    def _parse_group_conv(self) -> NodeProto:
        input_types = [EgglogTokenKind.VEC]
        output_types = [EgglogTokenKind.TENSOR_ID]

        attrs = [Attribute("attrs", EgglogTokenKind.CONV_ATTRS, None)]

        return self._get_node("GroupConv", input_types, output_types, attrs)

    def _parse_constant(self) -> NodeProto:
        output_types = [EgglogTokenKind.TENSOR_ID]

        attrs = [Attribute("value", EgglogTokenKind.TENSOR_TYPE, AttributeProto.TENSOR)]
        return self._get_node("Constant", [], output_types, attrs)

    def _parse_dequantize_linear(self) -> NodeProto:
        input_types = [
            EgglogTokenKind.TENSOR_ID,
            EgglogTokenKind.TENSOR_ID,
            EgglogTokenKind.TENSOR_ID,
        ]
        output_types = [EgglogTokenKind.TENSOR_ID]

        return self._get_node("DequantizeLinear", input_types, output_types)

    def _parse_dropout(self) -> NodeProto:
        input_types = [EgglogTokenKind.VEC]
        output_types = [EgglogTokenKind.VEC]

        attrs = [Attribute("seed", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT)]

        return self._get_node("Dropout", input_types, output_types, attrs)

    def _parse_empty(self) -> NodeProto:
        self._validate(self.lexer.next_token(), EgglogTokenKind.LEFT_PARENTHESIS)
        self._validate(self.lexer.next_token(), EgglogTokenKind.RIGHT_PARENTHESIS)

        return None

    def _parse_flatten(self) -> NodeProto:
        input_types = [EgglogTokenKind.TENSOR_ID]
        output_types = [EgglogTokenKind.TENSOR_ID]

        attrs = [Attribute("axis", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT)]

        return self._get_node("Flatten", input_types, output_types, attrs)

    def _parse_fused_conv_activation(self) -> NodeProto:
        input_types = [EgglogTokenKind.TENSOR_ID for _ in range(3)]
        output_types = [EgglogTokenKind.TENSOR_ID]

        attrs = [Attribute("attrs", EgglogTokenKind.FUSED_CONV_ATTRS, None)]

        return self._get_node(
            "FusedConv", input_types, output_types, attrs, has_domain=True
        )

    def _parse_fused_conv_batch_norm(self) -> NodeProto:
        input_types = [EgglogTokenKind.TENSOR_ID for _ in range(7)]
        output_types = [EgglogTokenKind.TENSOR_ID]

        attrs = [
            Attribute("conv_attrs", EgglogTokenKind.FUSED_CONV_ATTRS, None),
            Attribute("bn_attrs", EgglogTokenKind.BATCH_NORM_ATTRS, None),
        ]

        return self._get_node("FusedConvBatchNorm", input_types, output_types, attrs)

    def _parse_fused_gemm(self) -> NodeProto:
        input_types = [EgglogTokenKind.VEC]
        output_types = [EgglogTokenKind.TENSOR_ID]

        attrs = [Attribute("attrs", EgglogTokenKind.FUSED_GEMM_ATTRS, None)]

        return self._get_node(
            "FusedGemm", input_types, output_types, attrs, has_domain=True
        )

    def _parse_gather(self) -> NodeProto:
        input_types = [EgglogTokenKind.TENSOR_ID, EgglogTokenKind.TENSOR_ID]
        output_types = [EgglogTokenKind.TENSOR_ID]

        attrs = [Attribute("axis", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT)]
        return self._get_node("Gather", input_types, output_types, attrs)

    def _parse_gemm(self) -> NodeProto:
        input_types = [EgglogTokenKind.VEC]
        output_types = [EgglogTokenKind.TENSOR_ID]

        attrs = [Attribute("attrs", EgglogTokenKind.GEMM_ATTRS, None)]
        return self._get_node("Gemm", input_types, output_types, attrs)

    def _parse_global_average_pool(self) -> NodeProto:
        return self._get_node(
            "GlobalAveragePool",
            input_types=[EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.TENSOR_ID],
        )

    def _parse_matmul(self) -> NodeProto:
        return self._get_node(
            "MatMul",
            input_types=[EgglogTokenKind.TENSOR_ID, EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.TENSOR_ID],
        )

    def _parse_max_pool(self) -> NodeProto:
        return self._get_node(
            "MaxPool",
            input_types=[EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.VEC],
            attributes=[(Attribute("attrs", EgglogTokenKind.MAX_POOL_ATTRS, None))],
        )

    def _parse_mul(self) -> NodeProto:
        return self._get_node(
            "Mul",
            input_types=[EgglogTokenKind.TENSOR_ID, EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.TENSOR_ID],
        )

    def _parse_pad(self) -> NodeProto:
        input_types = [EgglogTokenKind.VEC]
        output_types = [EgglogTokenKind.TENSOR_ID]

        attrs = [
            Attribute("mode", EgglogTokenKind.STRING_LITERAL, AttributeProto.STRING)
        ]
        return self._get_node("Pad", input_types, output_types, attrs)

    def _parse_qcd_clip(self) -> NodeProto:
        input_types = [EgglogTokenKind.TENSOR_ID]
        output_types = [EgglogTokenKind.TENSOR_ID]

        attrs = [
            Attribute("bitwidth", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT)
        ]
        return self._get_node("QCDClip", input_types, output_types, attrs)

    def _parse_quantize_linear(self) -> NodeProto:
        return self._get_node(
            "QuantizeLinear",
            input_types=[
                EgglogTokenKind.TENSOR_ID,
                EgglogTokenKind.TENSOR_ID,
                EgglogTokenKind.TENSOR_ID,
            ],
            output_types=[EgglogTokenKind.TENSOR_ID],
        )

    def _parse_q_linear_add(self) -> NodeProto:
        return self._get_node(
            "QLinearAdd",
            input_types=[EgglogTokenKind.VEC],
            output_types=[EgglogTokenKind.TENSOR_ID],
            has_domain=True,
        )

    def _parse_q_linear_conv(self) -> NodeProto:
        return self._get_node(
            "QLinearConv",
            input_types=[EgglogTokenKind.VEC],
            output_types=[EgglogTokenKind.TENSOR_ID],
            attributes=[Attribute("attrs", EgglogTokenKind.CONV_ATTRS, None)],
        )

    def _parse_q_linear_global_average_pool(self) -> NodeProto:
        return self._get_node(
            "QLinearGlobalAveragePool",
            input_types=[EgglogTokenKind.VEC],
            output_types=[EgglogTokenKind.TENSOR_ID],
            attributes=[
                Attribute(
                    "channels_last", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT
                )
            ],
            has_domain=True,
        )

    def _parse_q_linear_matmul(self) -> NodeProto:
        return self._get_node(
            "QLinearMatMul",
            input_types=[EgglogTokenKind.VEC],
            output_types=[EgglogTokenKind.TENSOR_ID],
        )

    def _parse_reduce_mean(self) -> NodeProto:
        return self._get_node(
            "ReduceMean",
            input_types=[EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.TENSOR_ID],
            attributes=[
                Attribute("axes", EgglogTokenKind.VEC, AttributeProto.INTS),
                Attribute(
                    "keepdims", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT
                ),
            ],
        )

    def _parse_relu(self) -> NodeProto:
        return self._get_node(
            "Relu",
            input_types=[EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.TENSOR_ID],
        )

    def _parse_reshape(self) -> NodeProto:
        return self._get_node(
            "Reshape",
            input_types=[EgglogTokenKind.TENSOR_ID, EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.TENSOR_ID],
        )

    def _parse_shape(self) -> NodeProto:
        return self._get_node(
            "Shape",
            input_types=[EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.TENSOR_ID],
        )

    def _parse_sigmoid(self) -> NodeProto:
        return self._get_node(
            "Sigmoid",
            input_types=[EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.TENSOR_ID],
        )

    def _parse_softmax(self) -> NodeProto:
        return self._get_node(
            "Softmax",
            input_types=[EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.TENSOR_ID],
            attributes=[
                Attribute("axis", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT)
            ],
        )

    def _parse_split(self) -> NodeProto:
        return self._get_node(
            "Split",
            input_types=[EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.VEC],
            attributes=[
                Attribute("axis", EgglogTokenKind.INTEGER_LITERAL, AttributeProto.INT),
                Attribute("split", EgglogTokenKind.VEC, AttributeProto.INTS),
            ],
        )

    def _parse_squeeze(self) -> NodeProto:
        return self._get_node(
            "Squeeze",
            input_types=[EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.TENSOR_ID],
            attributes=[Attribute("axes", EgglogTokenKind.VEC, AttributeProto.INTS)],
        )

    def _parse_transpose(self) -> NodeProto:
        return self._get_node(
            "Transpose",
            input_types=[EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.TENSOR_ID],
            attributes=[Attribute("perm", EgglogTokenKind.VEC, AttributeProto.INTS)],
        )

    def _parse_unsqueeze(self) -> NodeProto:
        return self._get_node(
            "Unsqueeze",
            input_types=[EgglogTokenKind.TENSOR_ID],
            output_types=[EgglogTokenKind.TENSOR_ID],
            attributes=[Attribute("axes", EgglogTokenKind.VEC, AttributeProto.INTS)],
        )
